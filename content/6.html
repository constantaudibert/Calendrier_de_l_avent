<style>
    .nonogram-game {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        user-select: none;
        font-family: 'Montserrat', sans-serif;
    }

    .game-board {
        display: grid;
        /* 15 columns for the grid + 1 for row hints */
        grid-template-columns: 120px repeat(15, 20px);
        grid-template-rows: 60px repeat(15, 20px);
        gap: 1px;
        background-color: #d4af37;
        padding: 5px;
        border-radius: 5px;
        position: relative;
    }

    .cell,
    .header-cell,
    .row-hint {
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 10px;
        font-weight: bold;
        color: #333;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
    }

    .cell {
        cursor: pointer;
        transition: background-color 0.1s;
    }

    .cell:hover {
        background-color: #f0f0f0;
    }

    .cell.error {
        background-color: #ff4444 !important;
        animation: shake 0.3s;
    }

    @keyframes shake {

        0%,
        100% {
            transform: translateX(0);
        }

        25% {
            transform: translateX(-2px);
        }

        75% {
            transform: translateX(2px);
        }
    }

    .cell.filled {
        background-color: #2c3e50;
        /* Dark blue/grey */
    }

    .cell.crossed {
        color: #d4af37;
        font-size: 16px;
    }

    .cell.crossed::after {
        content: '√ó';
    }

    .header-cell {
        flex-direction: column;
        justify-content: flex-end;
        padding-bottom: 5px;
        white-space: pre-line;
        line-height: 1.2;
    }

    .row-hint {
        justify-content: flex-end;
        padding-right: 5px;
        letter-spacing: 3px;
    }

    .empty-corner {
        background-color: transparent;
    }

    #win-screen {
        display: none;
        flex-direction: column;
        align-items: center;
        animation: fadeIn 2s ease;
        text-align: center;
    }

    .cat-reveal {
        max-width: 300px;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        margin: 20px 0;
    }

    .congrats-text {
        font-family: 'Satisfy', cursive;
        color: #d4af37;
        font-size: 2em;
        margin-bottom: 10px;
    }

    .controls {
        margin-top: 10px;
        font-size: 0.9em;
        color: #ddd;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
    }

    .tool-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid #d4af37;
        color: #d4af37;
        padding: 8px 15px;
        border-radius: 20px;
        cursor: pointer;
        font-family: 'Montserrat', sans-serif;
        font-weight: bold;
        transition: all 0.2s;
    }

    .tool-btn:hover {
        background: rgba(212, 175, 55, 0.2);
    }

    .tool-btn.active {
        background: #d4af37;
        color: #fff;
        box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    .grid-overlay {
        position: absolute;
        /* 5px padding + 120px header + 1px gap = 126px offset */
        left: 126px;
        top: 51px;
        /* 15 cells * 20px + 14 gaps * 1px = 314px */
        width: 314px;
        height: 314px;
        object-fit: fill;
        opacity: 0;
        pointer-events: none;
        z-index: 10;
        transition: opacity 2s ease-in-out;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(20px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
</style>

<div class="nonogram-game" id="game-container">
    <h2 id="game-title" style="font-family: 'Satisfy', cursive; color: #d4af37; font-size: 2em; margin: 0;">Nonogramme
        invers√©
    </h2>
    <div class="controls" id="controls">
        <button class="tool-btn active" id="btn-fill" onclick="setTool(1)">‚¨õ</button>
        <button class="tool-btn" id="btn-cross" onclick="setTool(2)">‚ùå</button>
    </div>
    <div class="controls" id="controls-hint" style="font-size: 0.8em; margin-top: 5px;">
        Les indices indiquent le nombre de cases colori√©es dans chaque ligne et chaque colonne. Sauras tu r√©soudre ce
        nonogramme ?
    </div>

    <div class="game-board" id="board">
        <!-- Generated by JS -->
    </div>
</div>

<div id="win-screen">
    <div class="congrats-text">Bravo ! üê±</div>
    <img src="images/chat.jpg" alt="Le vrai chat" class="cat-reveal">
    <p style="color: #fff;">Tu as r√©solu le Nonogramme !</p>
</div>

<script>
    // 15x15 Cat Face Pattern (1 = filled, 0 = empty)
    const solution = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1],
        [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1],
        [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],
        [1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0],
        [0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
        [1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1],
        [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1],
        [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1],
        [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
        [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
    ];

    const gridSize = 15;
    let playerGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0)); // 0: empty, 1: filled, 2: crossed

    let isDragging = false;
    let currentTool = 1; // 1 = Fill, 2 = Cross

    function setTool(tool) {
        currentTool = tool;
        document.getElementById('btn-fill').classList.toggle('active', tool === 1);
        document.getElementById('btn-cross').classList.toggle('active', tool === 2);
    }

    function calculateHints(line) {
        let hints = [];
        let count = 0;
        for (let cell of line) {
            if (cell === 1) {
                count++;
            } else if (count > 0) {
                hints.push(count);
                count = 0;
            }
        }
        if (count > 0) hints.push(count);
        return hints.length > 0 ? hints : [0];
    }

    function initGame() {
        const board = document.getElementById('board');
        board.innerHTML = '';

        // Calculate hints
        const rowHints = solution.map(row => calculateHints(row));
        const colHints = [];
        for (let c = 0; c < gridSize; c++) {
            let col = [];
            for (let r = 0; r < gridSize; r++) {
                col.push(solution[r][c]);
            }
            colHints.push(calculateHints(col));
        }

        // Render Header (Top-Left corner empty + Column Hints)
        const corner = document.createElement('div');
        corner.className = 'empty-corner';
        board.appendChild(corner);

        colHints.forEach(hint => {
            const cell = document.createElement('div');
            cell.className = 'header-cell';
            cell.innerHTML = hint.join('<br>');
            board.appendChild(cell);
        });

        // Render Rows (Row Hint + Grid Cells)
        for (let r = 0; r < gridSize; r++) {
            // Row Hint
            const hintCell = document.createElement('div');
            hintCell.className = 'row-hint';
            hintCell.textContent = rowHints[r].join(' ');
            board.appendChild(hintCell);

            // Grid Cells
            for (let c = 0; c < gridSize; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;

                // Mouse Events (Desktop)
                cell.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click
                        isDragging = true;
                        // Use current tool
                        handleInput(r, c, cell, currentTool);
                    }
                });

                cell.addEventListener('mouseenter', () => {
                    if (isDragging) {
                        handleInput(r, c, cell, currentTool);
                    }
                });

                // Right click (Cross) - Forces Cross tool logic temporarily
                cell.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    // Right click always acts as "The other tool" or specifically Cross?
                    // Standard behavior: Right click = Cross.
                    // Let's force tool 2 for this action
                    handleInput(r, c, cell, 2);
                });

                board.appendChild(cell);
            }
        }

        // Add Overlay Image
        const overlay = document.createElement('img');
        overlay.src = 'images/chat.jpg';
        overlay.className = 'grid-overlay';
        board.appendChild(overlay);

        // Global Mouse Up
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Touch Events (Mobile)
        board.addEventListener('touchstart', handleTouchStart, { passive: false });
        board.addEventListener('touchmove', handleTouchMove, { passive: false });
        board.addEventListener('touchend', () => { isDragging = false; });
    }

    function handleTouchStart(e) {
        e.preventDefault();
        isDragging = true;
        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        if (element && element.classList.contains('cell')) {
            const r = parseInt(element.dataset.r);
            const c = parseInt(element.dataset.c);
            handleInput(r, c, element, currentTool);
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (!isDragging) return;
        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        if (element && element.classList.contains('cell')) {
            const r = parseInt(element.dataset.r);
            const c = parseInt(element.dataset.c);
            handleInput(r, c, element, currentTool);
        }
    }

    function handleInput(r, c, cellElement, tool) {
        // tool: 1 = Fill, 2 = Cross

        // If already filled or crossed, do nothing
        if (playerGrid[r][c] !== 0) return;

        const correctValue = solution[r][c]; // 1 (Fill) or 0 (Empty -> Cross)

        // Determine if the user's intention (tool) matches the solution
        // Tool 1 matches Solution 1.
        // Tool 2 matches Solution 0.

        let isCorrect = false;
        if (tool === 1 && correctValue === 1) isCorrect = true;
        if (tool === 2 && correctValue === 0) isCorrect = true;

        if (isCorrect) {
            // Apply the tool
            if (tool === 1) {
                playerGrid[r][c] = 1;
                cellElement.classList.add('filled');
            } else {
                playerGrid[r][c] = 2;
                cellElement.classList.add('crossed');
            }
            checkWin();
        } else {
            // Error! User used wrong tool for this cell.
            cellElement.classList.add('error');
            setTimeout(() => {
                cellElement.classList.remove('error');
                // Auto-correct: Apply the *correct* state
                if (correctValue === 1) {
                    playerGrid[r][c] = 1;
                    cellElement.classList.add('filled');
                } else {
                    playerGrid[r][c] = 2;
                    cellElement.classList.add('crossed');
                }
                checkWin();
            }, 500);
        }
    }

    function checkWin() {
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                const required = solution[r][c];
                const current = playerGrid[r][c] === 1 ? 1 : 0;
                if (required !== current) return;
            }
        }
        gameWon();
    }

    function gameWon() {
        // Reveal the image
        const overlay = document.querySelector('.grid-overlay');
        if (overlay) overlay.style.opacity = '1';

        // Hide controls
        document.getElementById('controls').style.display = 'none';
        document.getElementById('controls-hint').style.display = 'none';

        // Update Title
        const title = document.getElementById('game-title');
        title.textContent = "Bravo ! üê±";
        title.style.fontSize = "3em";
        title.style.animation = "shake 0.5s infinite"; // Petit effet festif

        if (window.confetti) window.confetti();
    }

    initGame();
</script>